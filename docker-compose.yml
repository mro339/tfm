name: federated-learning

services: #Lista de servicios que se van a levantar
          #En este caso vamos a levantar un servidor y dos clientes
  server:
    build: ./server #La ruta donde se encuentra el Dockerfile del servidor
    container_name: fl-server #Nombre del contenedor del servidor
    ports: #Mapeo de puertos para acceder al servidor desde el host. Es decir, publica el puerto 8080 del contender al puerto 8080 del host (afrition)
      - "8080:8080"
    networks: #Red donde se van a comunicar los contenedores. Conecta el contenedor del servidor a la red flnet
      - flnet

  client1:
    build: ./client #La ruta donde se encuentra el Dockerfile del cliente
    container_name: fl-client1 #así se llama el contenedor del cliente 1
    environment: #Variables de entorno para el contenedor del cliente 1
      - CLIENT_ID=1
    depends_on: #Indica que el contenedor del cliente 1 depende del contenedor del servidor, es decir, el servidor debe estar levantado antes que el cliente 1
      - server
    networks: #Red donde se van a comunicar los contenedores. Conecta el contenedor del cliente 1 a la red flnet
      - flnet

  client2: #Lo mismo para el cliente 2
    build: ./client
    container_name: fl-client2
    environment:
      - CLIENT_ID=2
    depends_on:
      - server
    networks:
      - flnet

networks: #Definición de la red personalizada llamada flnet
  flnet: #Nombre de la red
    driver: bridge #Tipo de red, en este caso una red puente (bridge) que permite la comunicación entre los contenedores dentro de la misma red
                   #DNS interno para resolver nombres de contenedores dentro de la red

#Debtri del fl-cliente1, resolviendo server:8080 usas el DNS interno para llegar al servidor sin exponer IPs externo. Esto hace que la comunicación sea exactamente como "máquinas separadas" en la misma LAN virtual.

